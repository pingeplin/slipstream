### Anthropic API Integration Requirements Analysis

Based on the `docs/slipstream-prd.md` and existing prompt templates, here are the core requirements
for the Anthropic API integration:

#### 1. Core Functionality

- **Model**: Use `claude-haiku-4-5` (supports structured outputs beta feature, cost-efficient)
- **Task**: Structure raw OCR text into a standardized JSON format.
- **Structured Output**: Use Anthropic's `output_format` with `json_schema` type and the
  `client.beta.messages.parse()` SDK method for reliable structured output with automatic
  Pydantic validation.
- **Beta Feature**: Requires `structured-outputs-2025-11-13` beta header
- **Input**: Raw text string from OCR.
- **Output**: Validated Pydantic model with automatic parsing via `response.parsed_output`

#### 2. Data Schema Requirements

The LLM must extract data matching the following Pydantic model (passed via `output_format`
parameter):

- `merchant_name`: String
- `date`: YYYY-MM-DD format (must handle ROC year conversion for Taiwan receipts)
- `total_amount`: Number
- `currency`: ISO code (default TWD)
- `items`: List of objects (description, quantity, unit_price, amount)
- `tax`: Number (optional)
- `payment_method`: String (optional)
- `invoice_number`: String (optional)
- `confidence_score`: 0.0 to 1.0
- `raw_text`: String (the original OCR text)

#### 3. Technical Requirements

- **Async Handling**: Support asynchronous requests using `AsyncAnthropic` client
- **Structured Outputs**: Use `client.beta.messages.parse()` with Pydantic models for automatic
  schema transformation and validation
- **Beta Header**: Include `betas=["structured-outputs-2025-11-13"]` parameter
- **Template Integration**: Use `prompts/extractor_system.jinja2` and
  `prompts/extractor_user.jinja2`
- **Parameter Control**: Support configuration of `temperature`, `max_tokens`, etc.
- **Token Usage**: Track input and output tokens for cost monitoring
- **Error Handling**: Handle API timeouts, rate limits, refusals (`stop_reason: "refusal"`),
  and max token limits (`stop_reason: "max_tokens"`)
- **Retry Strategy**: Implement exponential backoff for transient API errors
- **Schema Validation**: Automatic validation via SDK's `parsed_output` attribute

---

### TDD Implementation Plan: Anthropic API Integration

#### 1. Suggested Test Organization

- `tests/unit/integrations/test_anthropic.py`: Unit tests for the client wrapper.
- `tests/integration/test_anthropic_live.py`: (Optional) Live API tests with restricted scope.
- `tests/fixtures/ocr_samples/`: Directory containing sample OCR text and expected JSON outputs for
  testing.

#### 2. Test Scenarios (Simple to Complex)

| Scenario ID | Description              | Expected Input                      | Expected Output                         |
|:------------|:-------------------------|:------------------------------------|:----------------------------------------|
| **TS-01**   | Client Initialization    | API Key, Model Name                 | AsyncAnthropic client with beta config  |
| **TS-02**   | Prompt Rendering         | OCR Text                            | Rendered system and user messages       |
| **TS-03**   | Mock Structured Output   | Mocked JSON response                | Validated `Receipt` via `parsed_output` |
| **TS-04**   | Schema Transformation    | Pydantic Model                      | Auto-transformed JSON schema by SDK     |
| **TS-05**   | Handle Empty/Invalid OCR | Gibberish or empty string           | Receipt with low confidence or nulls    |
| **TS-06**   | ROC Date Conversion      | "114/11/17"                         | "2025-11-17" in parsed output           |
| **TS-07**   | Currency Detection       | "Â¥1000" or "$50"                    | "JPY" or "USD" in parsed output         |
| **TS-08**   | Item Extraction          | Multi-line item text                | List of `ReceiptItem` in parsed output  |
| **TS-09**   | API Error Handling       | 429 Rate Limit, Refusal, Max Tokens | Appropriate error or retry              |
| **TS-10**   | Token Usage Tracking     | Any valid request                   | Usage object with input/output counts   |

#### 3. Implementation Milestones (TDD Order)

**Phase 1: Foundation (Red-Green-Refactor)**

1. **Test**: Define `Receipt` and `ReceiptItem` Pydantic models based on PRD schema requirements.
2. **Test**: Initialize `AsyncAnthropic` client with beta configuration and verify setup.
3. **Test**: Verify Jinja2 templates load and render correctly with OCR variables.
4. **Test**: Verify SDK auto-transforms Pydantic model to compatible JSON schema.

**Phase 2: Core Extraction (Red-Green-Refactor)**

1. **Test**: Mock `client.beta.messages.parse()` to return a structured response with
   `parsed_output`.
2. **Implement**: Minimal `AnthropicClient.extract_receipt_data()` using
   `client.beta.messages.parse()` with `output_format=Receipt` and
   `betas=["structured-outputs-2025-11-13"]`.
3. **Test**: Verify that `response.parsed_output` returns a valid `Receipt` Pydantic instance.
4. **Test**: Add assertions for field types, date formats, and required fields.

**Phase 3: Robustness & Edge Cases**

1. **Test**: Simulate API failure modes (Rate limit, Timeout, Auth error, Refusal, Max tokens).
2. **Implement**: Add retry logic using `tenacity` for transient errors (non-refusal failures).
3. **Test**: Handle `stop_reason: "refusal"` - response returns 200 but may not match schema.
4. **Test**: Handle `stop_reason: "max_tokens"` - incomplete output, retry with higher limit.
5. **Implement**: Error handling for invalid/incomplete structured outputs.

**Phase 4: Optimization & Monitoring**

1. **Test**: Verify token usage is captured from the response object.
2. **Implement**: Return wrapper containing both `parsed_output` and usage metadata.
3. **Test**: Verify grammar caching behavior for subsequent identical schema requests.

#### 4. Progress Checklist

- [x] **Phase 1: Foundation**
    - [x] Define `Receipt` and `ReceiptItem` Pydantic models
    - [x] Initialize `AsyncAnthropic` client with beta configuration
    - [x] Verify Jinja2 templates load and render correctly
    - [x] Verify SDK auto-transforms Pydantic model to compatible JSON schema
- [x] **Phase 2: Core Extraction**
    - [x] Mock `client.beta.messages.parse()` for structured response
    - [x] Implement `AnthropicClient.extract_receipt_data()` using `parse()`
    - [x] Verify `response.parsed_output` returns valid `Receipt` instance
    - [x] Add assertions for field types and formats
- [x] **Phase 3: Robustness & Edge Cases**
    - [x] Simulate API failure modes (Rate limit, Timeout, etc.)
    - [x] Implement retry logic using `tenacity`
    - [x] Handle `stop_reason: "refusal"`
    - [x] Handle `stop_reason: "max_tokens"`
    - [x] Implement error handling for invalid/incomplete structured outputs
- [x] **Phase 4: Optimization & Monitoring**
    - [x] Verify token usage is captured
    - [x] Implement wrapper for `parsed_output` and usage metadata
    - [x] Verify grammar caching behavior

#### 5. Mocking Strategy

- Use `pytest-mock` to patch `anthropic.AsyncAnthropic`
- Mock `client.beta.messages.parse()` to return response with `parsed_output` attribute
- Create `conftest.py` fixture providing pre-configured mock client with beta config
- Mock response should include both `parsed_output` (Receipt model) and `usage` (token counts)

#### 5. Error & Edge Case Strategy

- **Invalid Schema Output**: With structured outputs, this should not occur in normal operation.
  However, handle `stop_reason: "refusal"` (200 status but non-schema output) and
  `stop_reason: "max_tokens"` (incomplete output).
- **Refusal Handling**: Check `response.stop_reason == "refusal"` and raise appropriate error or
  log warning.
- **Max Tokens**: If `stop_reason == "max_tokens"`, retry with increased `max_tokens` or raise
  error.
- **Low Confidence**: If `confidence_score` < 0.5 threshold, log warning but return data.
- **Missing Optional Fields**: Pydantic automatically handles `None` values for optional fields per
  schema definition.
- **Schema Validation**: SDK's `parse()` method automatically validates against original Pydantic
  model constraints (even those not supported in structured outputs grammar).

---

### Example Implementation

Below is a conceptual example showing how to use the structured outputs approach:

```python
from anthropic import AsyncAnthropic
from pydantic import BaseModel
from typing import List, Optional


class ReceiptItem(BaseModel):
    description: str
    quantity: Optional[float] = None
    unit_price: Optional[float] = None
    amount: Optional[float] = None


class Receipt(BaseModel):
    merchant_name: str
    date: str  # YYYY-MM-DD format
    total_amount: float
    currency: str = "TWD"
    items: List[ReceiptItem] = []
    tax: Optional[float] = None
    payment_method: Optional[str] = None
    invoice_number: Optional[str] = None
    confidence_score: float
    raw_text: str


class AnthropicExtractor:
    def __init__(self, api_key: str):
        self.client = AsyncAnthropic(api_key=api_key)

    async def extract_receipt_data(self, ocr_text: str) -> Receipt:
        """Extract structured receipt data from OCR text using structured outputs."""

        # Render prompts from Jinja2 templates
        system_prompt = render_template("extractor_system.jinja2")
        user_prompt = render_template("extractor_user.jinja2", ocr_text=ocr_text)

        # Call API with structured outputs
        response = await self.client.beta.messages.parse(
            model="claude-haiku-4-5",
            max_tokens=2048,
            betas=["structured-outputs-2025-11-13"],
            system=system_prompt,
            messages=[
                {"role": "user", "content": user_prompt}
            ],
            output_format=Receipt,  # Pass Pydantic model directly
        )

        # Handle edge cases
        if response.stop_reason == "refusal":
            raise ExtractionRefusedError("Model refused to process the request")

        if response.stop_reason == "max_tokens":
            raise ExtractionIncompleteError("Response truncated due to token limit")

        # Access validated Pydantic model
        receipt = response.parsed_output

        # Log warnings for low confidence
        if receipt.confidence_score < 0.5:
            logger.warning(f"Low confidence score: {receipt.confidence_score}")

        # Return receipt with usage metadata
        return receipt, response.usage
```

**Key Points:**

- Use `client.beta.messages.parse()` instead of `client.messages.create()`
- Pass Pydantic model directly via `output_format` parameter
- Include `betas=["structured-outputs-2025-11-13"]` parameter
- Access result via `response.parsed_output` (already a validated Pydantic instance)
- Handle special `stop_reason` values ("refusal", "max_tokens")
- Token usage available in `response.usage`
